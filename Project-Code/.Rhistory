ss_res_ridge <- sum((actual - pop_ridge_preds)^2)
ss_tot_ridge <- sum((actual - mean(actual))^2)
pop_ridge_rsquared[[response_var_per_capita]] <- 1 - (ss_res_ridge / ss_tot_ridge)
}
warnings()
for (result in pop_lasso_results) {
print(result)
}
for (result in pop_ridge_results) {
print(result)
}
# Convert the list to a numeric vector
pop_ridge_mse_vector <- unlist(pop_ridge_mse)
pop_lasso_mse_vector <- unlist(pop_lasso_mse)
print(pop_ridge_mse)
print(pop_lasso_mse)
# Calculate the mean, excluding NA values
pop_mean_ridge_mse <- mean(pop_ridge_mse_vector, na.rm = TRUE)
pop_mean_lasso_mse <- mean(pop_lasso_mse_vector, na.rm = TRUE)
# Print the result
print(pop_mean_ridge_mse)
print(pop_mean_lasso_mse)
print(pop_mean_linear_mse)
print(pop_mean_glm_mse)
print(pop_ridge_rsquared)
print(pop_lasso_rsquared)
print(pop_ridge_rsquared)
print(pop_lasso_rsquared)
for (result in pop_linear_regression_results) {
print(result)  # Print each regression result
}
for (result in pop_glm_regression_results) {
print(result$r.squared)  # Print each regression result
}
for (result in pop_glm_regression_results) {
print(result)  # Print each regression result
}
for (result in pop_linear_regression_results) {
print(result)  # Print each regression result
}
## Linear Regressions
pop_linear_regression_results <- list()
pop_glm_regression_results <- list()
set.seed(123)
ntest = floor(nrow(per_capita_data) / 4)  # 1/3 of data is test
testid = sample(1:nrow(per_capita_data), ntest)  # indices of test obs
testset = per_capita_data[testid, ]
trainset = per_capita_data[-testid, ]
pop_linear_mse = list()
pop_glm_mse = list()
library(car)
for (i in 1:length(pop_emissions_vars)) {
response_var <- pop_emissions_vars[i]
response_var_per_capita <- paste0(response_var, "_per_capita")
print(response_var_per_capita)
# Check if response variable exists in trainset
if (!response_var_per_capita %in% colnames(trainset)) {
warning(paste("Response variable", response_var_per_capita, "not found in trainset."))
next
}
# Create a formula for the regression model using per capita values
formula <- as.formula(paste("`", response_var_per_capita, "` ~", paste('`', new_numcols, '`', collapse = " + ",sep = ''), sep = ''))
# Fit the regression model
pop_linear_regression_model <- lm(formula, data = trainset)
# Check VIF and handle aliased coefficients
#vif_values <- vif(pop_linear_regression_model)
#if (any(is.infinite(vif_values))) {
#  warning("Aliased coefficients found; consider adjusting the model.")
#  next  # Skip to the next variable
#}
# Calculate MSE and store results
actual = testset[[response_var_per_capita]]
pop_linear_preds = predict(pop_linear_regression_model, testset)
pop_linear_mse[[response_var]] <- mean((pop_linear_preds - actual)^2)
# Store the regression model results
pop_linear_regression_results[[response_var]] <- summary(pop_linear_regression_model)
}
for (result in pop_linear_regression_results) {
print(result)  # Print each regression result
}
for (result in pop_linear_regression_results) {
print(result$r.squared)  # Print each regression result
}
for (result in pop_linear_regression_results) {
print(result$r.squared)  # Print each regression result
}
for (result in pop_glm_regression_results) {
print(result)  # Print each regression result
}
for (i in 1:length(pop_emissions_vars)) {
response_var <- pop_emissions_vars[i]
response_var_per_capita <- paste0(response_var, "_per_capita")
print(response_var_per_capita)
# Check if response variable exists in trainset
if (!response_var_per_capita %in% colnames(trainset)) {
warning(paste("Response variable", response_var_per_capita, "not found in trainset."))
next
}
# Create a formula for the regression model using per capita values
formula <- as.formula(paste("`", response_var_per_capita, "` ~", paste('`', new_numcols, '`', collapse = " + ",sep = ''), sep = ''))
# Fit the regression model
pop_linear_regression_model <- lm(formula, data = trainset)
# Check VIF and handle aliased coefficients
#vif_values <- vif(pop_linear_regression_model)
#if (any(is.infinite(vif_values))) {
#  warning("Aliased coefficients found; consider adjusting the model.")
#  next  # Skip to the next variable
#}
# Calculate MSE and store results
actual = testset[[response_var_per_capita]]
pop_linear_preds = predict(pop_linear_regression_model, testset)
pop_linear_mse[[response_var]] <- mean((pop_linear_preds - actual)^2)
# Store the regression model results
pop_linear_regression_results[[response_var]] <- summary(pop_linear_regression_model)
}
for (result in pop_linear_regression_results) {
print(result$r.squared)  # Print each regression result
}
for (result in pop_glm_regression_results) {
print(result)  # Print each regression result
}
## Linear Regressions
pop_linear_regression_results <- list()
pop_glm_regression_results <- list()
set.seed(123)
ntest = floor(nrow(per_capita_data) / 4)  # 1/3 of data is test
testid = sample(1:nrow(per_capita_data), ntest)  # indices of test obs
testset = per_capita_data[testid, ]
trainset = per_capita_data[-testid, ]
pop_linear_mse = list()
pop_glm_mse = list()
library(car)
for (i in 1:length(pop_emissions_vars)) {
response_var <- pop_emissions_vars[i]
response_var_per_capita <- paste0(response_var, "_per_capita")
print(response_var_per_capita)
# Check if response variable exists in trainset
if (!response_var_per_capita %in% colnames(trainset)) {
warning(paste("Response variable", response_var_per_capita, "not found in trainset."))
next
}
# Create a formula for the regression model using per capita values
formula <- as.formula(paste("`", response_var_per_capita, "` ~", paste('`', new_numcols, '`', collapse = " + ",sep = ''), sep = ''))
# Fit the regression model
pop_linear_regression_model <- lm(formula, data = trainset)
pop_glm_regression_model <- glm(formula, data = trainset)
# Check VIF and handle aliased coefficients
#vif_values <- vif(pop_linear_regression_model)
#if (any(is.infinite(vif_values))) {
#  warning("Aliased coefficients found; consider adjusting the model.")
#  next  # Skip to the next variable
#}
# Calculate MSE and store results
actual = testset[[response_var_per_capita]]
pop_linear_preds = predict(pop_linear_regression_model, testset)
pop_linear_mse[[response_var_per_capita]] <- mean((pop_linear_preds - actual)^2)
pop_glm_preds = predict(pop_glm_regression_model, testset)
pop_glm_mse[[response_var_per_capita]] <- mean((pop_glm_preds - actual)^2)
# Store the regression model results
pop_linear_regression_results[[response_var_per_capita]] <- summary(pop_linear_regression_model)
pop_glm_regression_results[[response_var_per_capita]] <- summary(pop_glm_regression_model)
}
warnings()
# Calculate per capita values for each response variable
# Remove commas from Population column and convert to numeric
df$Population <- as.numeric(gsub(",", "", df$Population))
per_capita_data <- df
# Optional: Check for any warnings or NA values after conversion
if (any(is.na(df$Population))) {
warning("There are NA values in the Population column after conversion.")
}
for (response_var in emissions_vars) {
per_capita_data[[paste0(response_var, "_per_capita")]] <- per_capita_data[[response_var]] / df$Population
}
# Select only numeric columns
pop_numeric_cols <- sapply(df, is.numeric)
pop_numeric_df <- per_capita_data[, pop_numeric_cols, with = FALSE]
# Identify and remove emissions columns
pop_emissions_pattern <- "(tC)"
pop_emissions_vars <- grep(pop_emissions_pattern, colnames(pop_numeric_df), value = TRUE)
pop_numeric_df_no_emissions <- pop_numeric_df[, !colnames(pop_numeric_df) %in% pop_emissions_vars, with = FALSE]
pop_numeric_df_no_emissions = pop_numeric_df_no_emissions[,!colnames(pop_numeric_df_no_emissions) %in% c('Unnamed: 0', 'FIPS', 'STATEFIPS'), with = FALSE]
print(pop_emissions_vars)
## Linear Regressions
pop_linear_regression_results <- list()
pop_glm_regression_results <- list()
set.seed(123)
ntest = floor(nrow(per_capita_data) / 4)  # 1/3 of data is test
testid = sample(1:nrow(per_capita_data), ntest)  # indices of test obs
pop_testset = per_capita_data[testid, ]
pop_trainset = per_capita_data[-testid, ]
pop_linear_mse = list()
pop_glm_mse = list()
library(car)
for (i in 1:length(pop_emissions_vars)) {
response_var <- pop_emissions_vars[i]
response_var_per_capita <- paste0(response_var, "_per_capita")
print(response_var_per_capita)
# Check if response variable exists in trainset
if (!response_var_per_capita %in% colnames(trainset)) {
warning(paste("Response variable", response_var_per_capita, "not found in trainset."))
next
}
# Create a formula for the regression model using per capita values
formula <- as.formula(paste("`", response_var_per_capita, "` ~", paste('`', new_numcols, '`', collapse = " + ",sep = ''), sep = ''))
# Fit the regression model
pop_linear_regression_model <- lm(formula, data = pop_trainset)
pop_glm_regression_model <- glm(formula, data = pop_trainset)
# Check VIF and handle aliased coefficients
#vif_values <- vif(pop_linear_regression_model)
#if (any(is.infinite(vif_values))) {
#  warning("Aliased coefficients found; consider adjusting the model.")
#  next  # Skip to the next variable
#}
# Calculate MSE and store results
actual = testset[[response_var_per_capita]]
pop_linear_preds = predict(pop_linear_regression_model, testset)
pop_linear_mse[[response_var_per_capita]] <- mean((pop_linear_preds - actual)^2)
pop_glm_preds = predict(pop_glm_regression_model, testset)
pop_glm_mse[[response_var_per_capita]] <- mean((pop_glm_preds - actual)^2)
# Store the regression model results
pop_linear_regression_results[[response_var_per_capita]] <- summary(pop_linear_regression_model)
pop_glm_regression_results[[response_var_per_capita]] <- summary(pop_glm_regression_model)
}
for (result in pop_linear_regression_results) {
print(result$r.squared)  # Print each regression result
}
for (result in pop_glm_regression_results) {
print(result)  # Print each regression result
}
# Convert the list to a numeric vector
pop_linear_mse_vector <- unlist(pop_linear_mse)
pop_glm_mse_vector <- unlist(pop_glm_mse)
print(pop_glm_mse)
print(pop_linear_mse)
# Calculate the mean, excluding NA values
pop_mean_linear_mse <- mean(pop_linear_mse_vector, na.rm = TRUE)
pop_mean_glm_mse <- mean(pop_glm_mse_vector, na.rm = TRUE)
# Print the result
print(pop_mean_linear_mse)
print(pop_mean_glm_mse)
# Exclude the last entry
pop_linear_mse_vector_no_last <- pop_linear_mse_vector[-length(pop_linear_mse_vector)]
pop_glm_mse_vector_no_last <- pop_glm_mse_vector[-length(pop_glm_mse_vector)]
# Calculate the mean, excluding NA values
pop_mean_linear_mse <- mean(pop_linear_mse_vector_no_last, na.rm = TRUE)
pop_mean_glm_mse <- mean(pop_glm_mse_vector_no_last, na.rm = TRUE)
# Print the results
print(paste("Mean Linear MSE (excluding last entry):", pop_mean_linear_mse))
print(paste("Mean GLM MSE (excluding last entry):", pop_mean_glm_mse))
library(plyr)
library(tensorflow)
library(keras3)
library(data.table)
library(caret)
library(e1071)
library(DoubleML)
library(mlr3learners)
library(leaps)
library(mgcv)
library(gam)
library(dplyr)
tf$constant("Hello Tensorflow!")
df = fread("C:/Users/eliot/OneDrive/Desktop/ECONPROJECT/ALLData-MergedDS.csv")
print(colnames(df))
print(df[, c('Finance and insurance _x', 'Finance and insurance _y')])
column_types <- sapply(df, class)
print(column_types)
colnames(df) <- gsub("_x", " % change in real GDP", colnames(df))
colnames(df) <- gsub("_y", " (GDP)", colnames(df))
# Select only the columns that are numeric
numeric_cols <- sapply(df, is.numeric)
tf$constant("Hello Tensorflow!")
df = fread("C:/Users/eliot/OneDrive/Desktop/ECONPROJECT/ALLData-MergedDS.csv")
print(colnames(df))
print(df[, c('Finance and insurance _x', 'Finance and insurance _y')])
column_types <- sapply(df, class)
print(column_types)
colnames(df) <- gsub("_x", " % change in real GDP", colnames(df))
colnames(df) <- gsub("_y", " (GDP)", colnames(df))
# Select only the columns that are numeric
numeric_cols <- sapply(df, is.numeric)
numeric_df <- df[, numeric_cols, with = FALSE]
print(numeric_df)
print(numeric_df$`RES npt Coal (tC)`)
print(numeric_df$N10600)
# Calculate per capita values for each response variable
# Remove commas from Population column and convert to numeric
df$Population <- as.numeric(gsub(",", "", df$Population))
per_capita_data <- df
# Optional: Check for any warnings or NA values after conversion
if (any(is.na(df$Population))) {
warning("There are NA values in the Population column after conversion.")
}
for (response_var in emissions_vars) {
per_capita_data[[paste0(response_var, "_per_capita")]] <- per_capita_data[[response_var]] / df$Population
}
# Select only numeric columns
pop_numeric_cols <- sapply(df, is.numeric)
# Select only numeric columns
pop_numeric_cols <- sapply(per_capita_data, is.numeric)
pop_numeric_df <- per_capita_data[, pop_numeric_cols, with = FALSE]
# Identify and remove emissions columns
pop_emissions_pattern <- "(tC)"
pop_emissions_vars <- grep(pop_emissions_pattern, colnames(pop_numeric_df), value = TRUE)
pop_numeric_df_no_emissions <- pop_numeric_df[, !colnames(pop_numeric_df) %in% pop_emissions_vars, with = FALSE]
pop_numeric_df_no_emissions = pop_numeric_df_no_emissions[,!colnames(pop_numeric_df_no_emissions) %in% c('Unnamed: 0', 'FIPS', 'STATEFIPS'), with = FALSE]
##############################################################################
#Setup
rm(list=ls())
gc()
gc()
##############################################################################
#Setup
rm(list=ls())
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(plyr)
library(tensorflow)
library(keras3)
library(data.table)
library(caret)
library(e1071)
library(DoubleML)
library(mlr3learners)
library(leaps)
library(mgcv)
library(gam)
library(dplyr)
tf$constant("Hello Tensorflow!")
df = fread("C:/Users/eliot/OneDrive/Desktop/ECONPROJECT/ALLData-MergedDS.csv")
print(colnames(df))
print(df[, c('Finance and insurance _x', 'Finance and insurance _y')])
column_types <- sapply(df, class)
print(column_types)
colnames(df) <- gsub("_x", " % change in real GDP", colnames(df))
colnames(df) <- gsub("_y", " (GDP)", colnames(df))
# Select only the columns that are numeric
numeric_cols <- sapply(df, is.numeric)
numeric_df <- df[, numeric_cols, with = FALSE]
print(numeric_df)
print(numeric_df$`RES npt Coal (tC)`)
print(numeric_df$N10600)
# Calculate per capita values for each response variable
# Remove commas from Population column and convert to numeric
df$Population <- as.numeric(gsub(",", "", df$Population))
per_capita_data <- df
# Optional: Check for any warnings or NA values after conversion
if (any(is.na(df$Population))) {
warning("There are NA values in the Population column after conversion.")
}
for (response_var in emissions_vars) {
per_capita_data[[paste0(response_var, "_per_capita")]] <- per_capita_data[[response_var]] / df$Population
}
# Select only numeric columns
pop_numeric_cols <- sapply(per_capita_data, is.numeric)
pop_numeric_df <- per_capita_data[, pop_numeric_cols, with = FALSE]
# Identify and remove emissions columns
pop_emissions_pattern <- "(tC)"
pop_emissions_vars <- grep(pop_emissions_pattern, colnames(pop_numeric_df), value = TRUE)
pop_numeric_df_no_emissions <- pop_numeric_df[, !colnames(pop_numeric_df) %in% pop_emissions_vars, with = FALSE]
pop_numeric_df_no_emissions = pop_numeric_df_no_emissions[,!colnames(pop_numeric_df_no_emissions) %in% c('Unnamed: 0', 'FIPS', 'STATEFIPS'), with = FALSE]
for (response_var in pop_emissions_vars) {
per_capita_data[[paste0(response_var, "_per_capita")]] <- per_capita_data[[response_var]] / df$Population
}
numeric_cols <- sapply(per_capita_data, is.numeric)
numeric_df <- per_capita_data[, numeric_cols, with = FALSE]
print(colnames(pop_numeric_df_no_emissions))
set.seed(123)
ntest = floor(nrow(per_capita_data) / 4)  # 1/3 of data is test
testid = sample(1:nrow(per_capita_data), ntest)  # indices of test obs
pop_testset = per_capita_data[testid, ]
pop_trainset = per_capita_data[-testid, ]
pop_linear_mse = list()
pop_glm_mse = list()
library(car)
# Store column names as a matrix
numcols <- colnames(pop_numeric_df_no_emissions)
# Convert relevant columns to a matrix
new_numcols = numcols
thresholds= c(0.99,0.95,0.9,0.85,0.8)
print(length(new_numcols))
for (t in thresholds) {
numcols_matrix <- as.matrix(trainset[, ..new_numcols, with = FALSE])
# Calculate the correlation matrix
correlation_matrix <- cor(numcols_matrix, use = "pairwise.complete.obs")
#print(correlation_matrix)
threshold <- t  # Set your correlation threshold
# Find indices of correlated pairs
correlated_indices <- which(abs(correlation_matrix) > threshold, arr.ind = TRUE)
# Remove self-correlations (where variable is correlated with itself)
correlated_pairs <- correlated_indices[correlated_indices[, 1] != correlated_indices[, 2], ]
# Get the names of the correlated variable pairs
correlated_var_pairs <- data.frame(
Variable1 = rownames(correlation_matrix)[correlated_pairs[, 1]],
Variable2 = colnames(correlation_matrix)[correlated_pairs[, 2]],
Correlation = correlation_matrix[correlated_pairs]
)
# Count occurrences of each variable in Variable1
frequency_table <- table(correlated_var_pairs$Variable1)
# Find the variable with the maximum frequency
most_frequent_variable <- names(frequency_table)[which.max(frequency_table)]
most_frequent_count <- max(frequency_table)
# Print the result
cat("Most frequent variable:", most_frequent_variable, "appears", most_frequent_count, "times.\n")
##print(length(unique(rownames(frequency_table))))
#print(unique(rownames(frequency_table)))
limit_freq = 110-100*t
high_freq <- names(frequency_table[frequency_table > limit_freq])
print(high_freq)
new_numcols <- new_numcols[!(new_numcols %in% high_freq)]
print(length(new_numcols))
}
for (t in thresholds) {
numcols_matrix <- as.matrix(pop_trainset[, ..new_numcols, with = FALSE])
# Calculate the correlation matrix
correlation_matrix <- cor(numcols_matrix, use = "pairwise.complete.obs")
#print(correlation_matrix)
threshold <- t  # Set your correlation threshold
# Find indices of correlated pairs
correlated_indices <- which(abs(correlation_matrix) > threshold, arr.ind = TRUE)
# Remove self-correlations (where variable is correlated with itself)
correlated_pairs <- correlated_indices[correlated_indices[, 1] != correlated_indices[, 2], ]
# Get the names of the correlated variable pairs
correlated_var_pairs <- data.frame(
Variable1 = rownames(correlation_matrix)[correlated_pairs[, 1]],
Variable2 = colnames(correlation_matrix)[correlated_pairs[, 2]],
Correlation = correlation_matrix[correlated_pairs]
)
# Count occurrences of each variable in Variable1
frequency_table <- table(correlated_var_pairs$Variable1)
# Find the variable with the maximum frequency
most_frequent_variable <- names(frequency_table)[which.max(frequency_table)]
most_frequent_count <- max(frequency_table)
# Print the result
cat("Most frequent variable:", most_frequent_variable, "appears", most_frequent_count, "times.\n")
##print(length(unique(rownames(frequency_table))))
#print(unique(rownames(frequency_table)))
limit_freq = 110-100*t
high_freq <- names(frequency_table[frequency_table > limit_freq])
print(high_freq)
new_numcols <- new_numcols[!(new_numcols %in% high_freq)]
print(length(new_numcols))
}
## Linear Regressions
pop_linear_regression_results <- list()
pop_glm_regression_results <- list()
for (i in 1:length(pop_emissions_vars)) {
response_var <- pop_emissions_vars[i]
response_var_per_capita <- paste0(response_var, "_per_capita")
print(response_var_per_capita)
# Check if response variable exists in trainset
if (!response_var_per_capita %in% colnames(trainset)) {
warning(paste("Response variable", response_var_per_capita, "not found in trainset."))
next
}
# Create a formula for the regression model using per capita values
formula <- as.formula(paste("`", response_var_per_capita, "` ~", paste('`', new_numcols, '`', collapse = " + ",sep = ''), sep = ''))
# Fit the regression model
pop_linear_regression_model <- lm(formula, data = pop_trainset)
pop_glm_regression_model <- glm(formula, data = pop_trainset)
# Check VIF and handle aliased coefficients
#vif_values <- vif(pop_linear_regression_model)
#if (any(is.infinite(vif_values))) {
#  warning("Aliased coefficients found; consider adjusting the model.")
#  next  # Skip to the next variable
#}
# Calculate MSE and store results
actual = testset[[response_var_per_capita]]
pop_linear_preds = predict(pop_linear_regression_model, testset)
pop_linear_mse[[response_var_per_capita]] <- mean((pop_linear_preds - actual)^2)
pop_glm_preds = predict(pop_glm_regression_model, testset)
pop_glm_mse[[response_var_per_capita]] <- mean((pop_glm_preds - actual)^2)
# Store the regression model results
pop_linear_regression_results[[response_var_per_capita]] <- summary(pop_linear_regression_model)
pop_glm_regression_results[[response_var_per_capita]] <- summary(pop_glm_regression_model)
}
for (i in 1:length(pop_emissions_vars)) {
response_var <- pop_emissions_vars[i]
response_var_per_capita <- paste0(response_var, "_per_capita")
print(response_var_per_capita)
# Check if response variable exists in trainset
if (!response_var_per_capita %in% colnames(pop_trainset)) {
warning(paste("Response variable", response_var_per_capita, "not found in trainset."))
next
}
# Create a formula for the regression model using per capita values
formula <- as.formula(paste("`", response_var_per_capita, "` ~", paste('`', new_numcols, '`', collapse = " + ",sep = ''), sep = ''))
# Fit the regression model
pop_linear_regression_model <- lm(formula, data = pop_trainset)
pop_glm_regression_model <- glm(formula, data = pop_trainset)
# Check VIF and handle aliased coefficients
#vif_values <- vif(pop_linear_regression_model)
#if (any(is.infinite(vif_values))) {
#  warning("Aliased coefficients found; consider adjusting the model.")
#  next  # Skip to the next variable
#}
# Calculate MSE and store results
actual = pop_testset[[response_var_per_capita]]
pop_linear_preds = predict(pop_linear_regression_model, pop_testset)
pop_linear_mse[[response_var_per_capita]] <- mean((pop_linear_preds - actual)^2)
pop_glm_preds = predict(pop_glm_regression_model, pop_testset)
pop_glm_mse[[response_var_per_capita]] <- mean((pop_glm_preds - actual)^2)
# Store the regression model results
pop_linear_regression_results[[response_var_per_capita]] <- summary(pop_linear_regression_model)
pop_glm_regression_results[[response_var_per_capita]] <- summary(pop_glm_regression_model)
}
for (result in pop_linear_regression_results) {
print(result$r.squared)  # Print each regression result
}
for (result in pop_glm_regression_results) {
print(result)  # Print each regression result
}
